%% filename - correct_z_value.m
%% Author - Satmeet Ubhi (satmeet.ubhi@gmail.com) 

%% Description -  This file reads the ground truth file (in xls format) and
%                 recomputes the Z value from the MAT file generated by Ctrax. 
%   

function [res_data, gtr] = compute_z_value()
    clc;
%   Declare globals
    get_file=0;
    height_of_bowl = 9.525* 5.8152; % (9.525 * trx(1).x/trx(1).x_mm) taken from w_get_height.m
    
    % set this variable so as to find the flies with X and Y locations from
    % ground truth data and ctrax mat file. e.g. if fly(1).x(1) is same as (trx(1).x(1) +/- margin)
    % I have tested with different values and 8 seems to be the most
    % suitable value. It finds all the flies in MAT and Ground truth file. 
    range = 1; 
    
    %% read ground truth file
    if get_file ~= 0
        helpmsg = 'Choose "Ground truth" file to analyse';
        [xlsname,xlspath] = uigetfilehelp('*.xls;*.xlsx','Choose ground truth file to analyze','helpmsg',helpmsg);
        pathtofile = [xlspath, xlsname];
        [gtruth_data, delimiter] = xlsread(pathtofile);
    else
        [gtruth_data, delimiter] = xlsread('C:\Users\satmeet\Desktop\modified_xls_25_2.xlsx');
    end

    %% read mat file
    if get_file ~= 0
        helpmsg2 = 'Choose MAT file to analyse';
        [matname,matpath] = uigetfilehelp('*.mat','Choose MAT file to analyze','helpmsg',helpmsg2);
        pathtomatfile = [matpath, matname];
        mat_data = load(pathtomatfile);
    else
        mat_data = load('C:\Users\satmeet\Desktop\fly- data\Fly_Tracking\MAT\FIXED_ MAT_BMAA090925_CAM25_DAY2.mat_converted.mat');
    end

    %% Prepare/Initialize variables
    nflies=length (mat_data.trx);
    fprintf('No of Flies in MAT file are: %d \n', nflies); 

    mat_trx = struct([]);

    %% Identify each fly in ground truth and in MAT file by X and Y values of flies
    
    
    %% calculate Z and Z_MM position of the fly for a given X and Y
    for fly=1:nflies
        len = length(mat_trx);

        mat_trx(len+1).x = mat_data.trx(fly).x;
        mat_trx(len+1).y = mat_data.trx(fly).y;
        z_struct = calculate_z(mat_data.trx(fly));
        mat_trx(len+1).z = z_struct.z;
        mat_trx(len+1).frame = z_struct.frame;        
        mat_trx(len+1).z_mm = z_struct.z_mm;        
    end
    
    %% We now have the z values for every X,Y location of the fly.
    % Now identify the flies in the ground_truth file with the MAT file by
    % comparing the X,Y values.
    
    gtr = prepare_gTruth_struct(gtruth_data);
    % number of flies in groud truth data
    nflies_gtruth = length(gtr);
    fprintf('No of flies in ground truth file is %d \n', nflies_gtruth );
    fprintf('\n|||||||||||||||||||||||||||||||||||||||\n');    

    res_data= struct([]);
     for fly = 1:nflies_gtruth
%     for fly = 1:1
        for flyinmat = 1:nflies
%              fprintf('\n\n +++++++\ncomparing X - fly %d in GROUND TRUTH with fly %d in MAT file \n++++++++\n', fly, flyinmat);

            for fid=1:numel(gtr(fly).x)

                if(numel(mat_trx(flyinmat).x) >= gtr(fly).frame(fid))
%                      fprintf('\n comparing X position - %f (ground truth) and %f (MAT) at frame %d ',...
%                                gtr(fly).x(fid), mat_trx(flyinmat).x(gtr(fly).frame(fid)),gtr(fly).frame(fid));
                    if (((gtr(fly).x(fid) - range) <= mat_trx(flyinmat).x(gtr(fly).frame(fid))) && ...
                            (mat_trx(flyinmat).x(gtr(fly).frame(fid)) <= (gtr(fly).x(fid) + range)))
                        fprintf('\n *** match found - { fly %d (GT) <--> fly %d (MAT) } at frame %d ', ...
                                fly, flyinmat, gtr(fly).frame(fid));
                        % Match found, copy the following info:-
                        % X, Y from Ctrax

                        if(gtr(fly).frame(fid) == max(gtr(fly).frame) )
                           next_frame = gtr(fly).frame(fid);
                        else
                           next_frame = gtr(fly).frame(fid+1); 
                        end
                        fprintf('\n\t copy all X and Y from frame %d to frame %d from fly %d (MAT)', gtr(fly).frame(fid),next_frame, flyinmat);
                        for iloop =gtr(fly).frame(fid):next_frame
                            res_data(fly).x(iloop) = mat_trx(flyinmat).x(iloop);
                            res_data(fly).y(iloop) = mat_trx(flyinmat).y(iloop);                           
                        end
                    else
                        % if match not found, copy the values from the
                        % Ground truth file. Assuming the fly was static, we copy
                        % the same X,Y of the fly at the last frame it was located in the
                        % Ground truth file
                        if(gtr(fly).frame(fid) == max(gtr(fly).frame) )
                           next_frame = gtr(fly).frame(fid);
                        else
                           next_frame = gtr(fly).frame(fid+1); 
                        end
%                             fprintf('\n\t\t copy all X and Y from frame %d to frame %d (index %d )from fly %d (GT)', gtr(fly).frame(fid),next_frame,fid ,fly);
                            for iloop =gtr(fly).frame(fid):next_frame
                                res_data(fly).x(iloop) = gtr(fly).x(fid);
                                res_data(fly).y(iloop) = gtr(fly).y(fid);
                            end
                    end
                else
%                      fprintf('\n ==========\nExceeded range for fly %d (MAT) in frame %d for fly %d (GT) (index %d)\n ==========\n',...
%                          flyinmat, gtr(fly).frame(fid), fly,fid);
                     break;
                end
            end
             %fprintf('\n ########## End comparing fly %d (MAT) ############# \n\n', flyinmat);
        end

         %fprintf('\n ***** End comparing fly %d (GT)*****', fly);
         fprintf('\n +++++++++++++++++++++++++++++++++++++');
     end
     
     % add the z values to the result
%      z_struct = calculate_z(res_data(1));
%      res_data(1).z = z_struct.z;
%      res_data(1).z_mm = z_struct.z_mm;
end

%% This function, taken from Wade Chen's project for CSCI-172, has been modified and calculates
%   the Z value from given x and y, it also adds another parameter, frame, to the mat file.

function [z_struct] = calculate_z(fly_trx)

    z_struct = struct([]);
    
    res = [1024 1024];
    center1 = [res(1)/4 res(2)/4]; 
    center2 = [res(1)/4+res(1)/2 res(2)/4];
    center3 = [res(1)/4 res(2)/4+res(2)/2];  
    center4 = [res(1)/4+res(1)/2 res(2)/4+res(2)/2];

    px = fly_trx.x/fly_trx.x_mm; %mm to pixel multiplier
    mx = fly_trx.x_mm/fly_trx.x; %pixel to mm multiplier
    d1 = 76.2*px; %bowl wide in pixel
    d2 = 9.525*px; %bowl hight in pixel

    ii = 1; %frame number
    %for each frame, compute z
    while( ii <=max(size(fly_trx.x)))
        org_x = fly_trx.x(ii);
        org_y = fly_trx.y(ii);

        if(org_x<res(1)/2) && (org_y<res(2)/2);
            newxy = [1 0 -center1(1); 0 1 -center1(2); 0 0 1]*[org_x; org_y; 1];        
        elseif(org_x>=res(1)/2) && (org_y<res(2)/2);
            newxy = [1 0 -center2(1); 0 1 -center2(2); 0 0 1]*[org_x; org_y; 1];
        elseif(org_x<res(1)/2) && (org_y>=res(2)/2);
            newxy = [1 0 -center3(1); 0 1 -center3(2); 0 0 1]*[org_x; org_y; 1];
        elseif(org_x>=res(1)/2) && (org_y>=res(2)/2);
            newxy = [1 0 -center4(1); 0 1 -center4(2); 0 0 1]*[org_x; org_y; 1];
        else continue;
        end

        x = newxy(1); % new x value
        a = atan(d1/d2);
        b = 90 - a;
        c = a - b;
        d3 = tan(c)*d1;
        r = d3/sin(c);
        d = asin(x/r);
        rp = x/tan(d);
        z = r - rp;  % height in pixel value
        z_mm = z*mx;
        
        z_struct(1).z(ii) = z;
        z_struct(1).frame(ii) = ii;
        z_struct(1).z_mm(ii) = z_mm;
        
        ii = ii + 1;

        
    end

end

%% Ground truth data is in the form:
% Floor/Ceiling | Frame_num | X | Y
function gtr = prepare_gTruth_struct(gtruth)
    gtr = struct([]);
    sid = 1;
    len = 1;
    for i= 1:length(gtruth)
        %check for cells having NaN
        if (isnan(gtruth(i,1)))
            len = len + 1;
            sid = 1;
        else
            gtr(len).x(sid) = gtruth(i,3);
            gtr(len).y(sid) = gtruth(i,4);
            gtr(len).frame(sid) = gtruth(i,2);
            gtr(len).pos(sid) = gtruth(i,1);
            sid = sid + 1;
        end
    end
end
